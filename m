Return-Path: <linux-kselftest+bounces-294-lists+linux-kselftest=lfdr.de@vger.kernel.org>
X-Original-To: lists+linux-kselftest@lfdr.de
Delivered-To: lists+linux-kselftest@lfdr.de
Received: from sv.mirrors.kernel.org (sv.mirrors.kernel.org [139.178.88.99])
	by mail.lfdr.de (Postfix) with ESMTPS id 965A07F1152
	for <lists+linux-kselftest@lfdr.de>; Mon, 20 Nov 2023 12:07:40 +0100 (CET)
Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by sv.mirrors.kernel.org (Postfix) with ESMTPS id 4E6F12823B7
	for <lists+linux-kselftest@lfdr.de>; Mon, 20 Nov 2023 11:07:39 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 9037E12B8F;
	Mon, 20 Nov 2023 11:07:36 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="l4XK5BYn"
X-Original-To: linux-kselftest@vger.kernel.org
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.43])
	by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 54C0713E;
	Mon, 20 Nov 2023 03:07:32 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1700478452; x=1732014452;
  h=date:from:to:cc:subject:in-reply-to:message-id:
   references:mime-version;
  bh=+ENk/qI3aAhzoQvbdmTZGZGTHTjCD4Wz6VPEXQlwA/w=;
  b=l4XK5BYnxTgtAXfX1oiLZyqqJ5+g5cRc8YCYACJRU6rG8FGgyKiq9ZYy
   RZcHfwNUBWRpmT8/iM/AndcXUw13DTfZ5sd93gL1a+afLmknx83B2Bm34
   jSfMprWOmh09dcNNwiASpq/aCxAip6FV31tQrY7PuZ+t1ACvSOt5ZZHOw
   PYTvAugqE3W/Nxkixk1TuM1DTZTQfnGJISqFpglTvzHvoaD+4RWDNxjCH
   q9x3RvDZzBg13vBdJj8XEma0LyK+d7wl5/3KQmYDj4J+vIVByge76a6EM
   kIWzmX4w6VD+s3dHKRLHqH9lfivVP5h0r6Z41sIOpqEMNdPLpG8MVj/lH
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10899"; a="477807962"
X-IronPort-AV: E=Sophos;i="6.04,213,1695711600"; 
   d="scan'208";a="477807962"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by fmsmga105.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 20 Nov 2023 03:07:31 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10899"; a="766247695"
X-IronPort-AV: E=Sophos;i="6.04,213,1695711600"; 
   d="scan'208";a="766247695"
Received: from akeren-mobl.ger.corp.intel.com ([10.252.40.26])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 20 Nov 2023 03:07:29 -0800
Date: Mon, 20 Nov 2023 13:07:26 +0200 (EET)
From: =?ISO-8859-15?Q?Ilpo_J=E4rvinen?= <ilpo.jarvinen@linux.intel.com>
To: =?ISO-8859-15?Q?Maciej_Wiecz=F3r-Retman?= <maciej.wieczor-retman@intel.com>
cc: Fenghua Yu <fenghua.yu@intel.com>, 
    Reinette Chatre <reinette.chatre@intel.com>, Shuah Khan <shuah@kernel.org>, 
    LKML <linux-kernel@vger.kernel.org>, linux-kselftest@vger.kernel.org
Subject: Re: [PATCH] selftests/resctrl: Add non-contiguous CBMs CAT test
In-Reply-To: <ilacrcz7o6wq2zdl3szb3cpkkboo43t3t2oyk4cmv3iwarstkj@kk34x5q4fpas>
Message-ID: <1b7e4a12-f636-4722-a9c7-76f99c723ab@linux.intel.com>
References: <20231109112847.432687-1-maciej.wieczor-retman@intel.com> <879955f-d2d4-017-6694-5a031ec7f2@linux.intel.com> <ilacrcz7o6wq2zdl3szb3cpkkboo43t3t2oyk4cmv3iwarstkj@kk34x5q4fpas>
Precedence: bulk
X-Mailing-List: linux-kselftest@vger.kernel.org
List-Id: <linux-kselftest.vger.kernel.org>
List-Subscribe: <mailto:linux-kselftest+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kselftest+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="8323329-1441281498-1700478451=:2032"

  This message is in MIME format.  The first part should be readable text,
  while the remaining parts are likely unreadable without MIME-aware tools.

--8323329-1441281498-1700478451=:2032
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: 8BIT

On Mon, 20 Nov 2023, Maciej Wieczór-Retman wrote:
> On 2023-11-17 at 14:55:54 +0200, Ilpo Järvinen wrote:
> >On Thu, 9 Nov 2023, Maciej Wieczor-Retman wrote:
> >
> >> Non-contiguous CBM support for Intel CAT has been merged into the kernel
> >> with Commit 0e3cd31f6e90 ("x86/resctrl: Enable non-contiguous CBMs in
> >> Intel CAT") but there is no selftest that would validate if this feature
> >> works correctly.
> >> 
> >> The selftest needs to verify if writing non-contiguous CBMs to the
> >> schemata file behaves as expected in comparison to the information about
> >> non-contiguous CBMs support.
> >> 
> >> Add tests for both L2 and L3 CAT to verify if the return values
> >> generated by writing non-contiguous CBMs don't contradict the
> >> reported non-contiguous support information.

> >> @@ -342,6 +342,87 @@ static int cat_run_test(const struct resctrl_test *test, const struct user_param
> >>  	return ret;
> >>  }
> >>  
> >> +static int noncont_cat_run_test(const struct resctrl_test *test,
> >> +				const struct user_params *uparams)
> >> +{
> >> +	unsigned long full_cache_mask, cont_mask, noncont_mask;
> >> +	unsigned int eax, ebx, ecx, edx, ret, sparse_masks;
> >> +	char res_path[PATH_MAX];
> >> +	char schemata[64];
> >> +	int bit_center;
> >> +	FILE *fp;
> >> +
> >> +	/* Check to compare sparse_masks content to cpuid output. */
> >> +	snprintf(res_path, sizeof(res_path), "%s/%s/%s", INFO_PATH,
> >> +		 test->resource, "sparse_masks");
> >> +
> >> +	fp = fopen(res_path, "r");
> >> +	if (!fp) {
> >> +		perror("# Error in opening file\n");
> >> +		return errno;
> >> +	}
> >> +
> >> +	if (fscanf(fp, "%u", &sparse_masks) <= 0) {
> >> +		perror("Could not get sparse_masks contents\n");
> >> +		fclose(fp);
> >> +		return -1;
> >> +	}
> >> +
> >> +	fclose(fp);
> >
> >Add a function to do this conversion into resctrlfs.c.
> 
> By conversion do you mean the above calls to fopen, fscanf and fclose? Or did
> you mean the below __cpuid_count? Since you mention making get_cache_level
> non-static I assume the first is the case but just wanted to confirm.

You convert the 0/1 read from a resctrl related file into (unsigned) int 
here. Create a helper function for that into resctrlfs.c that returns int 
(to be able to return also errors) and just call it from here with the 
feature string you're interested in, the helper should deal with the rest.

> >> +	return !ret == !sparse_masks;
> >> +}
> >> +
> >> +static bool noncont_cat_feature_check(const struct resctrl_test *test)
> >> +{
> >> +	char res_path[PATH_MAX];
> >> +	struct stat statbuf;
> >> +
> >> +	snprintf(res_path, sizeof(res_path), "%s/%s/%s", INFO_PATH,
> >> +		 test->resource, "sparse_masks");
> >> +
> >> +	if (stat(res_path, &statbuf))
> >> +		return false;
> >
> >This looks generic enough that validate_resctrl_feature_request() should 
> >be somehow adapted to cover also these cases. Perhaps it would be best to 
> >just split validate_resctrl_feature_request() into multiple functions.
> 
> As in conditionally call a function inside validate_resctrl_feature_request()
> that would check for the existance of a particular file that would indicate if a
> feature is supported or not?

I meant that validate_resctrl_feature_request() should probably be split 
into 2 or 3 functions, each taking different arguments and one them 
checks mon_features, another presence of sparse_masks file (any file on 
the level actually).

> Does implementing it as a new entry in resctrl_test struct that would hold the
> desired filename seem reasonable?

I'm not convinced it's useful to put it into the test structure. A simple 
function that calls into one or more of the functions provided 
in resctrlfs.c seems enough for me.

> Or would it be better to pass it as a new function argument (similiar to 
> how "const char *feature" is used now)?

I'd create a separate function in resctrlfs.c instead (IMO, a new function 
should be also done for those callers which currently use const 
char *feature).


-- 
 i.

--8323329-1441281498-1700478451=:2032--

